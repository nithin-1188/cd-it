5.Implement RSA algorithm
  (a) Generate Public key and Private key pair-
  (b) Generate Cipher text for the Plaintext
  (c) Obtain the Plaintext from the Cipher text


#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
typedef long long ll;

/* Extended GCD */
ll extended_gcd(ll a, ll b, ll *x, ll *y){
    if(b==0){ *x=1; *y=0; return a; }
    ll x1,y1;
    ll g = extended_gcd(b, a % b, &x1, &y1);
    *x = y1;
    *y = x1 - (a / b) * y1;
    return g;
}

/* modular inverse */
ll modinv(ll a, ll m){
    ll x,y;
    ll g = extended_gcd(a,m,&x,&y);
    if(g != 1) return -1;
    x %= m; if(x < 0) x += m;
    return x;
}

/* safe modular multiplication using __int128, then powmod */
static inline ll modmul(ll a, ll b, ll mod){
    __int128 r = (__int128)a * (__int128)b;
    r %= mod;
    return (ll)r;
}
ll modexp(ll base, ll exp, ll mod){
    ll res = 1 % mod;
    base %= mod;
    while(exp > 0){
        if(exp & 1) res = modmul(res, base, mod);
        base = modmul(base, base, mod);
        exp >>= 1;
    }
    return res;
}

/* gcd */
ll gcd_ll(ll a, ll b){
    if(a<0) a = -a; if(b<0) b = -b;
    while(b){ ll t = a % b; a = b; b = t; }
    return a;
}

int main(void){
    ll p, q, e, msg;
    printf("Enter a prime number (p):\n");
    if(scanf("%lld", &p) != 1) return 0;

    printf("Enter another prime number (q):\n");
    if(scanf("%lld", &q) != 1) return 0;

    printf("Enter a public exponent (e) (co-prime to %lld, e.g., 7): ", (p-1)*(q-1));
    if(scanf("%lld", &e) != 1) return 0;

    printf("\nEnter a message (as a number < %lld): ", p*q);
    if(scanf("%lld", &msg) != 1) return 0;

    ll n = p * q;
    ll phi = (p - 1) * (q - 1);

    printf("\nOutput:\n\n");
    printf("n (modulus) pq %lld\n", n);
    printf("phi(n) (p-1) (q-1) %lld\n\n", phi);

    if (p <= 1 || q <= 1 || p == q) {
        printf("Invalid primes. p and q must be distinct primes > 1.\n");
        return 0;
    }
    if (msg < 0 || msg >= n) {
        printf("Warning: message should be in range 0 .. %lld\n", n-1);
    }
    if (gcd_ll(e, phi) != 1) {
        printf("Error: e is not coprime with phi(n). Choose different e.\n");
        return 0;
    }

    ll d = modinv(e, phi);
    if (d == -1) {
        printf("Error computing modular inverse d.\n");
        return 0;
    }

    printf("Key Generation\n\n");
    printf("Public Key: (e=%lld, n=%lld)\n", e, n);
    printf("Private Key: (d=%lld, n=%lld)\n\n", d, n);

    printf("Encrypting Plaintext: %lld\n\n", msg);
    ll c = modexp(msg, e, n);
    printf("Ciphertext (C = M^e mod n): %lld\n\n", c);

    printf("Decrypting Ciphertext: %lld\n\n", c);
    ll dec = modexp(c, d, n);
    printf("Decrypted Plaintext (M = C^d mod n): %lld\n", dec);

    return 0;
}

output:
------

Enter the number to be encrypted and decrypted
3
Enter 1st prime number p
3
Enter 2nd prime number q
5
the value of z = 8
the value of e = 3
the value of d = 3
Encrypted message is :-
12.000000
Derypted message is :-
3
